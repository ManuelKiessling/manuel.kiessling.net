<!DOCTYPE html>
<html lang='en'>

<head>
  <meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='description' content='Introduction The goal of this project is to teach you how to build successful Continuous Delivery setups for your software products. The goal of this post is to create a shared understanding of the different practices and principles that together are the foundation for Continuous Delivery setups that are stable, maintainable, and adaptable.
I call these the Five Pillars of a healthy Continuous Delivery setup.
These pillars are:
 Infrastructure-as-Code Immutable Servers Zero-Downtime Blue-Green Deployment Software Tests Software-based database Migrations  This is not an ordered list.'>

<meta property='og:title' content='The Five Pillars of a healthy Continuous Delivery setup • Manuel Kiessling'>
<meta property='og:description' content='Introduction The goal of this project is to teach you how to build successful Continuous Delivery setups for your software products. The goal of this post is to create a shared understanding of the different practices and principles that together are the foundation for Continuous Delivery setups that are stable, maintainable, and adaptable.
I call these the Five Pillars of a healthy Continuous Delivery setup.
These pillars are:
 Infrastructure-as-Code Immutable Servers Zero-Downtime Blue-Green Deployment Software Tests Software-based database Migrations  This is not an ordered list.'>
<meta property='og:url' content='https://develop-build-deploy.com/tutorials/the-five-pillars-of-a-healthy-continuous-delivery-setup/'>
<meta property='og:site_name' content='Develop Build Deploy'>
<meta property='og:type' content='article'><meta property='og:image' content='https://www.gravatar.com/avatar/8b50d5d8199a12f00cfbfd1061e224a9?s=256'><meta property='article:section' content='Tutorials'><meta property='article:tag' content='authors'><meta property='article:published_time' content='2018-01-17T16:13:00&#43;01:00'/><meta property='article:modified_time' content='2018-01-17T16:13:00&#43;01:00'/><meta name='twitter:card' content='summary'><meta name='twitter:creator' content='@manuelkiessling'>

<meta name="generator" content="Hugo 0.34" />

  <title>The Five Pillars of a healthy Continuous Delivery setup • Manuel Kiessling</title>
  <link rel='canonical' href='https://develop-build-deploy.com/tutorials/the-five-pillars-of-a-healthy-continuous-delivery-setup/'>
  
  
  <link rel='icon' href='/favicon.ico'>
<link rel='stylesheet' href='/assets/css/main.f0e8df71.css'><link rel='stylesheet' href='/css/custom.css'>
</head>


<body class='page type-tutorials'>
  <div class='site'>

    <a class='screen-reader' href='#main'>Skip to Content</a>

    <header id='header' class='header-container'>
      <div class='header site-header'>
        <nav id='main-menu' class='main-menu-container' aria-label='Main Menu'>
  <ul class='main-menu'>
  <li>
      <a href='/'>Home</a>
    </li>
  <li>
      <a href='/about/'>About</a>
    </li>
  <li>
      <a href=''></a>
    </li>
  
  </ul>
</nav>

        <div class='header-info'>
          
          <p class='site-title title'>Develop Build Deploy</p>
          
          <p class='site-description subtitle'>Your resource on infrastructure-as-code, immutable servers, blue/green deployment, and continuous delivery.</p>
        </div>
      </div>
    </header>


<main id='main' class='main'>
  <article lang='en' class='entry'>
    <header class='header-container'>
  <div class='header entry-header'>
    <div class='header-info'>
      <h1 class='title'>The Five Pillars of a healthy Continuous Delivery setup</h1>
      

    </div>
    
<div class='meta'>
  <span class='posted-on'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"/>
  <line x1="16" y1="2" x2="16" y2="6"/>
  <line x1="8" y1="2" x2="8" y2="6"/>
  <line x1="3" y1="10" x2="21" y2="10"/>
  
</svg>
<span class='screen-reader'>Posted on </span>
  <time class='date' datetime='2018-01-17T16:13:00&#43;01:00'>2018, Jan 17</time>
</span>

  <span class='byline'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <path d="M21,21V20c0-2.76-4-5-9-5s-9,2.24-9,5v1"/>
  <path d="M16,6.37A4,4,0,1,1,12.63,3,4,4,0,0,1,16,6.37Z"/>
  
</svg>
<span class='screen-reader'> by </span><a href='/authors/manuelkiessling'>Manuel Kiessling</a></span>
  
<span class='reading-time'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <circle cx="12" cy="12" r="10"/>
  <polyline points="12 6 12 12 15 15"/>
  
</svg>
8 mins read
</span>


</div>


  </div>
</header>

    
    

    <div class='entry-content'>
  

<h2 id="introduction">Introduction</h2>

<p>The goal of this project is to teach you how to build successful Continuous Delivery setups for your software products. The goal of this post is to create a shared understanding of the different practices and principles that together are the foundation for Continuous Delivery setups that are stable, maintainable, and adaptable.</p>

<p>I call these <em>the Five Pillars of a healthy Continuous Delivery setup</em>.</p>

<p>These pillars are:</p>

<ul>
<li>Infrastructure-as-Code</li>
<li>Immutable Servers</li>
<li>Zero-Downtime Blue-Green Deployment</li>
<li>Software Tests</li>
<li>Software-based database Migrations</li>
</ul>

<p>This is not an ordered list. All five practices and principles are equally important for a successful setup, and they reinforce each other to form a working whole.</p>

<p>Let&rsquo;s have a closer look at each:</p>

<h2 id="infrastructure-as-code">Infrastructure-as-Code</h2>

<p>Running a Continuous Delivery setup successfully always means running systems infrastructures (server systems, network rules, DNS entries, firewall settings, logging setups etc.) that is completely under your control, with no surprises lurking in dark corners.</p>

<p>Why? Because at the end of the day, system infrastructures are the playing field on which the Continuous Delivery game is played. And it is only played well if the playing field is kept in excellent condition.</p>

<p>You will use parts of these infrastructures to execute the Continuous Delivery setup itself, and you will use other parts as the delivery goal of your setup, the place where your applications and services will run.</p>

<p>If you don&rsquo;t have full control over these, you are out of the game: you will not be able to reliably deliver new functionality again and again with confidence if servers don&rsquo;t look the way you expect, if firewall rules are not in place as needed, or if DNS entries are a mess.</p>

<p>How do you achieve this state of running and managing well-maintained and well-understood infrastructures? Through an approach called Infrastructure-as-Code.</p>

<p>What is it that you need to do to do Infrastructure-as-Code? First and foremost, you must introduce tools which allow you to describe in a structured way what your infrastructure is supposed to look like, and let the tools do the heavy-lifting, as opposed to structuring your infrastructure design in your head and then build it manually.</p>

<p>Because this is the essence of the Infrastructure-as-Code principle:</p>

<p>Successful infrastructures are not the sum of all the things that a team <em>did</em> with the infrastructure, it is what a team <em>described or codified</em> as the target state of the infrastructure in such a clear and structured way that the actual doing can be delegated to specialized tools.</p>

<p>Let&rsquo;s illustrate this point. Imagine a simple web application infrastructure which consists of some web and some database servers, maybe some load balancers, and a certain network routing setup. Everything is set up correctly by hand, has been carefully tested, and is running smoothly.</p>

<p>Then, a new requirement appears: some servers which do not yet have a route on the network to another set of servers now need this route. No problem: someone from the sysops team adds the route definition by hand to the network setup, by hand. Everything is still working as desired.</p>

<p>But what if sometime later, the infrastructure encounters a problem, and has to be rebuilt, at least partly? Will the networking route which had been added be in place after the rebuild? Maybe, if the colleague who implemented it remembers to do so again. Maybe, if the route definition was part of a configuration backup that was made. Maybe, if the routing change has been documented.</p>

<p>From my personal experience with non-Infrastructure-as-Code setups I can report that typically, a lot of luck is involved in these cases. It&rsquo;s because the <em>desired target state</em> of such an infrastructure is only implicit - it is a floating state of knowledge distributed over the brains of the team members and glimmers of documentation here and there, never to be fully grasped, and re-achieved only by try-and-error whenever reloactions or outages demand a rebuild. And good luck onboarding new team members to such a setup.</p>

<p>On the opposite, Infrastructure-as-Code is the collection of an <em>explicitly codified target state</em> of the infrastructure. How this target state is achieved is up to the toolset used by the team.</p>

<p>In the course of this project, we will use <em>Terraform</em> to describe the target state of our AWS infrastructures.</p>

<p>A slightly simplified, yet typical Terraform declaration of the target state of a piece of infrastructure looks like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-hcl-terraform" data-lang="hcl-terraform">resource &#34;aws_instance&#34; &#34;bastion&#34; {
  count = 1    
  instance_type = &#34;t2.nano&#34;    
  ami = &#34;ami-12345&#34;
    
  root_block_device {
    volume_type = &#34;gp2&#34;
    volume_size = &#34;8&#34;
    delete_on_termination = true
  }
}</code></pre></div>
<p>This declares that the infrastructure must contain exactly one AWS EC2 instance named &ldquo;bastion&rdquo;, which is of type <em>t2.nano</em>, running a certain AMI, with a <em>gp2</em> block device that is 8 GB in size and is deleted on instance termination.</p>

<p>Nothing here tells Terraform how to actually provision this instance. The <em>how</em> is Terraform&rsquo;s problem. We only declare the <em>what</em>, the desired target state. With this code checked into a version control system, this instance is now an explicit part of our infrastructure. It&rsquo;s not &ldquo;the machine that Jim booted some month ago&rdquo;, long forgotten by everyone including Jim. If the instance is removed manually, or lost due to a crash, that&rsquo;s no big deal in terms of infrastructure management - Terraform will recreate it on its next run, because with the machine being lost, the desired target state is no longer fullfilled. And that&rsquo;s all what Terraform does: ensure the desired target state. It doesn&rsquo;t need a recipe for this (&ldquo;if a machine is gone, follow this procedure&rdquo;) - all it needs is the codified design of the required infrastructure.</p>

<p>If we compare the two approaches of hand-crafted infrastructure versus Infrastructure-as-Code with each other, we can identify the following advantages of the latter:</p>

<ul>
<li>The desired target state is explicit</li>
<li>Correctness does not depend on distributed knowledge</li>
<li>Teams can focus on the <em>what</em> and leave the <em>how</em> to the tools</li>
<li>New team members can browse the code and quickly get a full picture of the infrastructure</li>
<li>It is easy to reconstruct which changes to the infrastructure were introduced when and by whom, because the infrastructure definition is a version-controlled code repository</li>
</ul>

<p>Why is Infrastructure-as-Code an important pillar of a healthy Continuous Delivery setup? Because Continuous Delivery can only work if the environments through which deliveries run are well understood and predictable. At the end of the day, a Continuous Delivery setup is a bit like a production line in a factory - a lot of moving parts are involved, and they all need to be in exactly the right place for each and every delivery. The complexity such a setup, and the work involved in maintaining such a setup, which more often than not has to be done under time pressure, leaves no room for ambiguity and guesswork. Only an explicitly codified infrastructure design provisioned into life by dedicated tools can provides the required maintainability and stability over the lifespan of such a setup.</p>

<p>And, while not strictly a requirement to do Continuous Delivery successfully, it is a welcome side-effect that Infrastructure-as-Code setups tend to require much smaller operations teams than conventional setups: because teams need to put a lot less energy into the <em>how</em> of infrastructure provisioning (that&rsquo;s the job of the tools), and because team members need to juggle with a lot less implicit knowledge about the infrastructure design (that&rsquo;s all written down in the code base), a lot more productivit can be achieved even with a much smaller team.</p>

<h2 id="immutable-servers">Immutable Servers</h2>

<p>Infrastructure-as-Code setups love Immutable Servers. But first, what is an immutable server? Let&rsquo;s begin by looking at what a non-immutable server looks like. As an example, let&rsquo;s look at a typical web application server, for example one that hosts a PHP-based web app.</p>

<p>This server has a certain lifecycle. First and foremost, the server system itself is provisioned. Maybe as an EC2 instance via Terraform, if an Infrastructure-as-Code setup is already in place, maybe manually on-premise.</p>

<p>To fullfill its job, the server needs to be set up: an operating system needs to be installed and configured, the application has to be deployed onto the server, several services need to be launched. The server might be one of multiple systems which all look the same, running as a cluster behind a load-balancer, and therefore needs to be advertised to the load-balancer as a new origin server.</p>

<p>The interesting part in the lifecycle comes now: What happens with our server system when a new version of our application software is released, or if the system configuration itself (installed software packages, config files, etc.) needs to be updated?</p>

<p>In the classical approach, which is called <em>Phoenix Servers</em>, these changes happen in place, while the server system is running. A new application version is deployed, or other operation system software packages are updated, or config files changed and services restarted. This process can be made efficiently manageable by using configuration management software solutions like <em>Puppet</em>, <em>Chef</em>, <em>Ansible</em>, or <em>Salt</em>. The server itself lives on, probably for a very long time.</p>

<p>This works reasonably well and is an approach that is successfully applied for a lot of infrastructures worldwide.</p>

<p>-&gt; &ldquo;any change to a running system introduces risk&rdquo; !!!</p>

<p><a href="https://martinfowler.com/bliki/ImmutableServer.html" target="_blank">https://martinfowler.com/bliki/ImmutableServer.html</a></p>

</div>

    
<footer class='entry-footer-container'>
  <div class='entry-footer'>
  <div class='tags'>
  <span class='taxonomyTerm-icon'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <path d="M20.59,13.41l-7.17,7.17a2,2,0,0,1-2.83,0L2,12V2H12l8.59,8.59A2,2,0,0,1,20.59,13.41Z"/>
  <line x1="7" y1="7" x2="7" y2="7"/>
  
</svg>
</span>
  <span class='screen-reader'>Tags: </span><a class='tag' href='/tags/authors'>Authors</a></div>

  </div>
</footer>


  </article>
  
  
</main>

    <footer id='footer' class='footer-container'>
      <div class='footer'>
        <div class='social-menu-container'>
  <nav aria-label='Social Menu'>
    <ul class='social-menu'><li>
        <a href='https://github.com/manuelkiessling' target='_blank' rel='noopener'>
          <span class='screen-reader'>Open Github account in new tab</span><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"/>
  
</svg>
</a>
      </li><li>
        <a href='https://twitter.com/manuelkiessling' target='_blank' rel='noopener'>
          <span class='screen-reader'>Open Twitter account in new tab</span><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"/>
  
</svg>
</a>
      </li><li>
        <a href='mailto:manuel@kiessling.net' target='_blank' rel='noopener'>
          <span class='screen-reader'>Contact via Email</span><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"/>
  <polyline points="22,6 12,13 2,6"/>
  
</svg>
</a>
      </li></ul>
  </nav>
</div>
        <div class='copyright'>
  <p>
        
          
        
      

       &copy; 2017-2018 Manuel Kiessling 
  </p>
</div>

      </div>
    </footer>

  </div><script src='/assets/js/main.5871befd.js'></script><script src='/js/custom.js'></script></body>

</html>

